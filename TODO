http://www.w3.org/TR/2004/REC-rdf-primer-20040210
http://www.w3.org/TR/2011/WD-turtle-20110809
http://www.w3.org/TR/2011/WD-rdf11-concepts-20110830	1.1 version
http://www.w3.org/TR/2004/REC-rdf-concepts-20040210		1.0 version
http://www.w3.org/TR/2004/REC-rdf-mt-20040210			semantics
http://www.w3.org/TR/sparql11-query/
http://dbpedia.org/sparql

http://jena.sourceforge.net/ARQ/Tutorial/index.html


* Work on operators:
	- probably want an expression enum and eval_expr fn
	- == needs to use http://www.w3.org/TR/xpath-functions/#func-numeric-equal
	- fix the couple mixed type tests
	- || and && need to special case errors
	-  < and > 
	- probably want arithmatic operators, see http://www.w3.org/TR/sparql11-query/#OperatorMapping
* Work on more complex matching:
	- support some simple date filters (i.e. date is no more than 24 hours ago)
		` support comparisons
		` no support for subtracting dateTimes so user would have to do it
	- support filter inside of optional
	- may want to support union
* Select components can be strings?
	- if not why does triple pattern allow literals?
* Need to make sure solutions are not being copied willy nilly.
* Check some common parse errors and add tag as needed.
* Document whats not supported:
	- paths
	- collections
	- etc
* Do we need to be able to match collections?
* Concepts doc at 307 talks about escaping urls.
* Support common subjects and common prefixes (4.2.1 and 4.2.2)
* Add a unit test demonstrating that solutions can be sent across tasks.
* Add a unit test showing that add_triples args can be sent across threads.
* Get more queries working:
	- make sure that the features we have an immediate need for are all supported
	- 1402 has a nav example
		` apply second rule to results of the first rule?
	- can do queries with http://dbpedia.org/sparql
* Work on more stuff:
	- remove
	- clean
	- add_store
* May want to update readme.
* See if we can do a better job now with stuff like date.
* Add a sparql parser:
	- don't need the full thing for now
* May want to add to cargo.

* Run the w3c tests:
	- http://www.w3.org/2009/sparql/docs/tests/
	- will need a turtle parser and xml and probably more
* IRIs must be absolute (i.e. they must have a scheme name followed by a colon).
* Triple equality:
	- http://www.w3.org/TR/2011/WD-rdf11-concepts-20110830/#section-IRIs
	- http://www.w3.org/TR/2011/WD-rdf11-concepts-20110830/#section-Literal-Equality
* Should support CURIEs
	- http://www.w3.org/TR/2011/WD-rdf-interfaces-20110510/#terms--prefixes-and-profiles
* Will need a way to merge two triple sets
	- need to fixup blank nodes
* Optimization:
	- http://users.dcc.uchile.cl/~cgutierr/papers/tods09.pdf
* Add a turtle parser.

http://schemapedia.com/

/Users/jessejones/Documents/Developer/rust.rtf



SELECT ?x
WHERE {subject predicate object}

can use ?x to name a wildcard argument
IRIs appear as <http://foo/bar#blah>
strings as "foo"

WHERE can have multiple patterns
matches triples that match all the patterns
variable matches must match the same value

pattern can be appended with FILTER
FILTER regex(?x, "foo|bar") filters out triples that aren't foo/bar
FILTER NOT EXISTS {pattern} filters out triples that match pattern
FILTER EXISTS {pattern} filters out triples that don't match pattern
	does not add bindings (tho they nay be used)
FILTER (?age >= 24)

OPTIONAL {pattern}
adds a binding
binding may not actually have a value

pattern UNION pattern
returns triples that match either pattern
if distinct bindings are used then the unmatched binding won't have a value

ORDERBY ?x ?y	sort results
DISTINCT			don't return duplicate rows
OFFSET/LIMIT	slice results
ASK				return true/false instead of matches/no matches
	
STRSTARTS
STRENDS
CONTAINS


fn parse_dateTime(literal: str) -> option<std::time::timespec>
{
	// Time zone expressed as an offset from GMT, e.g. -05:00 for EST.
	alt std::time::strptime(literal, "%FT%T%z").chain_err
		{|_err1|
			// Time zone expressed as a name, e.g. EST (technically only Z is supposed to be allowed).
			std::time::strptime(literal, "%FT%T%Z").chain_err
			{|_err2|
				// No time zone (so the time will be considered to be in the local time zone).
				std::time::strptime(literal, "%FT%T")
			}}
	{
		result::ok(time)
		{
			option::some(time.to_timespec())
		}
		result::err(_)
		{
			#error["'%s' is not an ISO 8601 dateTime", literal];
			option::none
		}
	}
}

