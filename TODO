http://www.w3.org/TR/sparql11-query/
http://jena.sourceforge.net/ARQ/Tutorial/index.html


* Ignore case when comparing language.
* rdf:list has a fixed size, other collections are open.
	- probably want some add_collection methods
	- note that the open collections are 1-based
* Support SELECT * (selects all bindings).
* Support ; (goes in same place as .)
* Work on more complex matching:
	- support optional, use section 18 to figure out the algebra
	- support some simple date filters (i.e. date is no more than 24 hours ago)
		` support comparisons
		` no support for subtracting dateTimes so user would have to do it
	- support filter inside of optional
	- may want to support union
* Select components can be strings?
	- if not why does triple pattern allow literals?
* Check some common parse errors and add tag as needed.
* Document whats not supported:
	- paths
	- collections
	- etc
* Do we need to be able to match collections?
* Concepts doc at 307 talks about escaping urls.
* Add a unit test demonstrating that solutions can be sent across tasks.
* Add a unit test showing that add_triples args can be sent across threads.
* Add support for sequences, bags, and alternatives.
* Get more queries working:
	- make sure that the features we have an immediate need for are all supported
	- 1402 has a nav example
		` apply second rule to results of the first rule?
	- can do queries with http://dbpedia.org/sparql
* Work on more stuff:
	- remove
	- clean
	- add_store
* May want to update readme.
* See if we can do a better job now with stuff like date.
* Add a sparql parser:
	- don't need the full thing for now
* May want to add to cargo.

* Get the types setup.
	- rename predicate relation?
* Run the w3c tests:
	- http://www.w3.org/2009/sparql/docs/tests/
	- will need a turtle parser
* IRIs must be absolute (i.e. they must have a scheme name followed by a colon).
* Language tags must be non-empty and normalized to lower case.
* Should we have primitive or functions like get_i32_value?
* Triple equality:
	- http://www.w3.org/TR/2011/WD-rdf11-concepts-20110830/#section-IRIs
	- http://www.w3.org/TR/2011/WD-rdf11-concepts-20110830/#section-Literal-Equality
* Should support CURIEs
	- http://www.w3.org/TR/2011/WD-rdf-interfaces-20110510/#terms--prefixes-and-profiles
* Maybe want a (mutable) hashmap based tiplet store
	- subject => [(relation, object)]
	- http://www.w3.org/TR/2011/WD-rdf-interfaces-20110510/#graphs
* Will need a way to merge two triple sets
	- need to fixup blank nodes
* Might want a graph type, possibly based on a (hidden) hashset
* Maybe add some query methods
	- see http://en.wikipedia.org/wiki/Resource_Description_Framework#Query_and_inference_languages
* Add a turtle parser.

http://www.w3.org/TR/2004/REC-rdf-primer-20040210
http://www.w3.org/TR/2011/WD-turtle-20110809
http://www.w3.org/TR/2011/WD-rdf11-concepts-20110830	1.1 version
http://www.w3.org/TR/2004/REC-rdf-concepts-20040210		1.0 version
http://www.w3.org/TR/2004/REC-rdf-mt-20040210			semantics

http://schemapedia.com/

/Users/jessejones/Documents/Developer/rust.rtf



SELECT ?x
WHERE {subject predicate object}

can use ?x to name a wildcard argument
IRIs appear as <http://foo/bar#blah>
strings as "foo"

WHERE can have multiple patterns
matches triples that match all the patterns
variable matches must match the same value

pattern can be appended with FILTER
FILTER regex(?x, "foo|bar") filters out triples that aren't foo/bar
FILTER NOT EXISTS {pattern} filters out triples that match pattern
FILTER EXISTS {pattern} filters out triples that don't match pattern
	does not add bindings (tho they nay be used)
FILTER (?age >= 24)

OPTIONAL {pattern}
adds a binding
binding may not actually have a value

pattern UNION pattern
returns triples that match either pattern
if distinct bindings are used then the unmatched binding won't have a value

ORDERBY ?x ?y	sort results
DISTINCT			don't return duplicate rows
OFFSET/LIMIT	slice results
ASK				return true/false instead of matches/no matches
	
STRSTARTS
STRENDS
CONTAINS


fn parse_dateTime(literal: str) -> option<std::time::timespec>
{
	// Time zone expressed as an offset from GMT, e.g. -05:00 for EST.
	alt std::time::strptime(literal, "%FT%T%z").chain_err
		{|_err1|
			// Time zone expressed as a name, e.g. EST (technically only Z is supposed to be allowed).
			std::time::strptime(literal, "%FT%T%Z").chain_err
			{|_err2|
				// No time zone (so the time will be considered to be in the local time zone).
				std::time::strptime(literal, "%FT%T")
			}}
	{
		result::ok(time)
		{
			option::some(time.to_timespec())
		}
		result::err(_)
		{
			#error["'%s' is not an ISO 8601 dateTime", literal];
			option::none
		}
	}
}

